80. Remove Duplicates from Sorted Array II

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

#### 示例 1:

给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。

####  示例 2:

给定 nums = [0,0,1,1,1,1,2,3,3],

函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。

你不需要考虑数组中超出新长度后面的元素。

------
### my_own:

在原数组上进行修改，判断相邻的数是否相等，相等的情况记录重复次数，小于2时对数组前面重新赋值，重复次数大于2时跳过循环，判断下一个数。（同双指针法）

------

### solution(from pezy):

这道题是[24. Remove Duplicates from Sorted Array](../24. Remove Duplicates from Sorted Array)的升级版。

我也是根据上一道题的解法，稍作调整。

如，上一道题，如果 `n<2`， 就没啥可做的，直接返回，到这道题，就变成了 `n<3` 返回了。因为如果有 0，1 两个位置的元素，
无论它俩是否想等，都应该保留。所以我们的解决方案面对的场景，至少也是 `n==3`。画个图吧：

```cpp
1 1 1
  ^ ^
  s i
```

这算是一种极端情况，s 代表 size，即去重后的数组长度，i 就是迭代下标。由于上面分析了 `n==2` 无关紧要这个结论，
那么 s 完全可以从 A[1] 开始，而迭代过程，很自然就从 A[2] 开始了。但我们的目标是，上图情况下，s 应该不动，i 继续前行。
故有：

```cpp
if (A[i] == A[size] && A[i] == A[size-1])
    // size 不动
```

而继续延展画图：
```cpp
1 1 1 2 2 3
  ^   ^
 size i
```

此刻需要 size 前进一位，且赋值为 2 了。故有：
```cpp
if (A[i] != A[size])
    A[++size] = A[i];
```

再继续：
```cpp
1 1 2 2 2 3
    ^   ^
   size i
```

注意此刻，`A[i] == A[size]`，但 size 显然需要前进一位，因为 2 至少可以出现两次。故有：
```cpp
if (A[i] != A[size-1])
    A[++size] = A[i];
```

我们在验证一步：
```cpp
1 1 2 2 2 3
      ^   ^
    size  i
```

此刻又符合了之前的情况，能够说明其规律性了。结合三种条件，我们可以发现非常简单：
```cpp
if (A[i] != A[size] || A[i] != A[size-1])
    A[++size] = A[i];
```

最后，一定要注意，由于这次用的是前置自加，所以size并不代表真正的长度，而代表着最后一位的位置。所以返回时再自加一次。

OK。

