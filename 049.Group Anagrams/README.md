049. Group Anagrams

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

示例:

输入: ["eat", "tea", "tan", "ate",   "nat", "bat"],
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
说明：

所有输入均为小写字母。
不考虑答案输出的顺序。

my_own:
先对所有字符串排序，按abcd..xyz的顺序排列后比较，对相同的字符串进行编号后归类，主要在于得到selected数组，对应重复字符串的编号。

solution:
想要知道 Anagrams 出现几次，我们显然希望有一个分别计数的工具，对于一个 key (Anagrams 排序后相同的那个单词), 对应某个 value, 最好能标注出现多少次。

不需要犹豫，这一定是 Hash 表的干活，在 C++ 中，是 `unordered_map` 的干活。

-----

分析到这里，基本知道了解法，只不过为了更加高效，我希望能在一次迭代中搞定。那么如何定义 Hash 表的 value 很重要。

我们来整理一下逻辑:

- 如果 key 出现两次, ret.push_back(current_string);
- 如果 key 只出现一次, 显然应该置之不理

但问题在于，你不完整的迭代一次，如何能知道哪个 key 只出现一次？但反过来呢？我不关心哪个 key 只出现一次，只关心哪个 key 重复了，不就行了？

一旦重复，我 push 进入返回 vector, 并将第一次的单词也 push 进入返回 vector, 但要避免重复将第一次的单词 push, 需要做个标记。最好用一个无效值作为标记。

当我们用迭代器迭代 vector 的时候，最佳的天然无效值便是 `end()` 迭代器，如果已经将第一次的单词 push 过了，那么将这个 key 的 value 标记为 `end()`，下次发现是无效值，便无需再重复 push.

于是，我们就可以在一次迭代中完成整个逻辑了。

//运用stl结构！！
map<string, multiset<string>> m;
