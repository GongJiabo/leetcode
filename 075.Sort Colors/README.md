75. Sort Colors

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色  的元素相邻，并按照红色、白色、蓝色顺序排列。  

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。  

注意:  
不能使用代码库中的排序函数来解决这道题。  

示例:  
   
输入: [2,0,2,1,1,0]  
输出: [0,0,1,1,2,2]  

进阶：  
一个直观的解决方案是使用计数排序的两趟扫描算法。  
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。  
你能想出一个仅使用常数空间的一趟扫描算法吗？  

------------------------

my_own:  
三路快排思想，大于1的放右边，小于1的放左边，等于1的不动。
ps(快速排序)：https://blog.csdn.net/k_koris/article/details/80585979  

-----------------------

solution(from pezy):  
这道题的解决思路，一定要看看我的commits log，太经典了。我感觉我的脑袋都进化了。

第一次，我觉得这道题忒简单，排什么序啊，总共才三个元素，迭代一次，纪录各个元素的个数，但后再来一次迭代，按顺序赋值即可。

于是有了[第一次提交](https://github.com/pezy/LeetCode/blob/9db17b692f6accb548634f9160a14d0bb2c68f39/25.%20Sort%20Colors/solution.h#L4-L15)。

然后我去打扫房间了。。。

期间我想，这么简单一道题，花了两次迭代，忒不值了吧。于是我觉得可以用交换来减少迭代次数。但无论如何，第一次迭代也要走完，否则怎么能知道到底有多少个0呢？第二次迭代可以从仅仅包含1和2的位置开始迭代即可。无论如何也是减少了迭代量。但这样代码看起来就没那么直观了。

于是有了[第二次提交](https://github.com/pezy/LeetCode/blob/ecc31ada47a85e1a9d52717abed27e660766e008/25.%20Sort%20Colors/solution.h#L6-L14)。

刚刚提交完，我觉得不服气啊，也没简化多少，让 @Mooophy 看到搞不好还要笑话我。于是我就开始考虑，能否在一次迭代就解决这件事。

思维开始走到牛角尖里去了，于是我放下，继续去干点家务。

脑子里再想到这道题的时候，发现有一个盲点我没发现：为什么不在迭代数组的时候同时修改数组呢？由于平时常用的是vector，迭代vector的时候明令禁止修改vector。所以竟然形成了思维惯性。此刻我们用的是纯数组，完全不需要考虑这么多。

我只需要设置两个flag，一个在头，一个在尾（尾巴都不用设，n是现成的啊）。然后用i去迭代，遇到等于0的，往头部交换，头flag++。遇到等于2的，往尾部交换，然后n--。但尾部交换完有个细节，就是i往后走，会略过这个刚交换完的值，所以我们交换的时候也要让i退一步。如此这般，待i全部走完，0全都在头，2全部在尾，中间就全是1了。

最后的解决方案，只有**三行**。有比这个更简洁的代码，一定要告诉我。
