77. Combinations

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。  

示例:  

输入: n = 4, k = 2  
输出:  
[  
  [2,4],  
  [3,4],  
  [2,3],  
  [1,2],  
  [1,3],  
  [1,4],  
]  
  
-------

### my_own:   
From Leetcode  
回溯法：是一种通过遍历所有可能成员来寻找全部可行解的算法。若候选不是可行解(或者至少不是最后一个解)，回溯法会在前一步进行一些修改以舍弃该候选，换而言之，回溯并再次尝试。

这是一个回溯法函数，它将第一个添加到组合中的数和现有的组合作为参数。 backtrack(first, curr)

* 若组合完成添加到输出中。

* 遍历从 first t到 n的所有整数。

    - 将整数 i 添加到现有组合 curr中。

    - 继续向组合中添加更多整数:  
      backtrack(i + 1, curr).

    - 将 i 从 curr中移除，实现回溯。

--- 

### solution(from pezy):  

两个循环貌似就可以搞定：
```cpp
for (int i=1; i<=n; ++i)
    for (int j=i+1; j<=n; ++j)
        retv.push_back({i, j});
```

但这属于 k=2 的特殊情况。如果 k = 3 呢。

|pos 0|pos 1|pos 2|
|-----|-----|-----|
|1|2|3|
|1|2|4|
|1|3|4|
|2|3|4|

貌似就需要三个循环了：
```cpp
for (int i=0; i<=n; ++i)
    for (int j=i+1; j<=n; ++j)
        for (int k=j+1; k<=n; ++k)
            retv.push_back({i, j, k});
```

这不扯了么？k 等于多少，就要循环几次。有没有能够控制循环次数的循环？

有，但你可以想象这样的循环有多么不近人情，而且，这不是典型的**递归**的干活么。。。嗯，就是递归。（为啥需要递归，这时候真需要！）

`retv.push_back({i, j, k})`, 这样的东西无论如何也要改，可以先将 retv 的每一个 vec 初始化为 k 长度，然后使用 `vec[当前循环次数] = 当前循环参数;`。

```cpp
void combine(int i, int n, int k)
{
    while (i<=n)
    {
        vec[vec.size() - k] = i++;
        if (k == 1) retv.push_back(vec);
        else combine(i, n, k-1);
    }
}
```

这就是核心算法了，然后调此递归即可：`combine(1, n, k);`

-----

我的AC使用的是一种"倒着填"的类似方案，我觉得要更简洁一些。但写思路的时候，发现上面那样写，更加符合从 多次循环 到 递归 的思想。更近人情。
