44. Wildcard Matching

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。  

'?' 可以匹配任何单个字符。  
'*' 可以匹配任意字符串（包括空字符串）。  
两个字符串完全匹配才算匹配成功。  
  
说明:  

s 可能为空，且只包含从 a-z 的小写字母。  
p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

    示例 1:  
    输入:  
    s = "aa"  
    p = "a"  
    输出: false  
    解释: "a" 无法匹配 "aa" 整个字符串。  

    示例 2:  
    输入:  
    s = "aa"  
    p = "*"
    输出: true
    解释: '*' 可以匹配任意字符串。

    示例 3:
    输入:
    s = "cb"
    p = "?a"
    输出: false
    解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。

    示例 4:
    输入:
    s = "adceb"
    p = "*a*b"
    输出: true
    解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".

    示例 5:
    输入:
    s = "acdcb"
    p = "a*c?b"
    输入: false

Quote:
https://blog.csdn.net/qq_41231926/article/details/82732623

### 1. 逐个比较

1，将字符串s和p的字符挨个比较，i和j指针分别记录位置，如果相同或者p的j位置字符为’？’，则将i和j指针前进一步；
2，如果不满足第一步条件，但是此时p的j位置字符为 通配符’*’，那么就记录此时i和j的位置，并且将j前进一步；
3，再将i和前进一步的j重复，第一步的操作，如果还是不匹配，那么就需要通配符的匹配，就将当前i位置的元素直接匹配掉，拿着下一个元素和j位置的元素继续比较，并且更新记录中记录的位置；
4，如果没有完全匹配，或者匹配过程有错误，直接返回false；否则就直到将s字符串完全匹配完成；
5，如果已经完全匹配，但是p字符串指针j还没有遍历完成，那么就需要此时p剩下的字符串全部是通配符才算完全匹配，否则就返回false；
6，全部遍历完成，就说明匹配成功，返回true；

### 2. 递归实现

递归终止条件：

（1）当字符串p的长度为0时，若字符串s的长度也为0，返回true。若字符串s的长度不为0，返回false。

（2）当字符串s的长度为0时，如果此时字符串p中的字符全是'*'，返回true，否则，返回false。

递归过程：

（1）如果字符串s的最后一个字符能与字符串p的最后一个字符相匹配，我们递归地去判断字符串s去除最后一个字符后的字符串能否与字符串p去除最后一个字符后的字符串相匹配。

（2）如果字符串p的最后一个字符是'*'，我们需要去判断字符串s能否与字符串p去除最后一个字符后的字符串相匹配、字符串s去除最后一个字符后的字符串能否与字符串p去除最后一个字符后的字符串相匹配、字符串s去除最后两个字符后的字符串能否与字符串p去除最后一个字符后的字符串相匹配、……、空字符串能否与字符串p去除最后一个字符后的字符串相匹配。只要这其中有一个能匹配，就应该返回true。如果都不能匹配，返回false。

（3）如果不满足前面两种情况，说明字符串s的最后一个字符不能与字符串p的最后一个字符相匹配，直接返回false。

这个思路的时间复杂度比较复杂，最差情况可能是O(ns * np)级别的，其中ns为字符串s的长度，np为字符串p的长度。空间复杂度就是递归深度，最差情况也是O(ns * np)级别的。

### 3. 动态规划

构建辅助数组dp，dp[i][j]表示s(0~i-1)与p(0~j-1)子串是否完全匹配

需s和p完全匹配，外层循环对p进行遍历，内层循环对待匹配字符串s进行遍历，每次对S的当前字符(s[i-1])进行匹配时，判断p的当前字符(p[j-1])是否为'*'；

若p[j-1]不为*，需判断s(0~i-2)与p(0~j-2)是否匹配（即dp[i-1][j-1]），并且s[i-1]与p[j-1]匹配

若p[j-1]为,需判断s(0~i-2)与p(0~j-1)是否匹配（当前匹配s[i-1]及之前部分字符），或者判断s(0~i-1)与p(0~j-2)是否匹配(当前*匹配空字符串)
