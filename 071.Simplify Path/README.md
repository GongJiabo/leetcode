71. Simplify Path

相对路径的组成部分。更多信息请参阅：[Linux / Unix中的绝对路径 vs 相对路径](https://blog.csdn.net/u011327334/article/details/50355600)

请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。

 

示例 1：

输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
示例 2：

输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
示例 3：

输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
示例 4：

输入："/a/./b/../../c/"
输出："/c"
示例 5：

输入："/a/../../b/../c//.//"
输出："/c"
示例 6：

输入："/a//b////c/d//././/.."
输出："/a/b/c"

### my_own:

首先对路径字符串处理，以"/"为分隔符，提取每个文件夹的名称，之后再通过对"."与".."的判断化简路径。

其中需要主要对".."处理时，多个父目录的结果最多只到根目录，重组时注意"/"的放置。

### solution(from pezy):

这是个好题目，很有实际需求。

    /a/./b/../../c/
      ^^                (1)
    /a/b/../../c/
       ^^^^             (2)
    /a/../c/
     ^^^^               (2)
    //c/
    ^^                  (3)
    /c/
      ^                 (4)
    /c

我们只需要认真分析题目给出的第二个例子，就能发现几种变换方式：

1. `.` 代表当前目录，可忽略
2. `..` 代表上一级目录，应退到前一个 `/` 处
3. `//` 合并为 `/`
4. 末尾`/`删除

显然，我们的进退应该按照 `/` 来区分，这是**关键**。我们应该对路径字符串进行以 `/` 的切割。
然后一段一段的入栈出栈。接下来，我们倒过来写，看看 `/a/./b/../../c/` 入栈情况：

可分割为以下部分：

    a | . | b | .. | .. | c

| character | action | stack  |
| :-------: | :----: | :----: |
|   a       |   push |   a    |
|   .       | ignore |   a    |
|   b       |   push |   a b  |
|   ..      |   pop  |   a    |
|   ..      |   pop  |        |
|   c       |   push |   c    |

最后将结果补充上 `/` 即可：`/c`.

-----

整理一下逻辑:

1. 遇到 `..` ，若 stack 不为空的话，pop 操作
2. 继续，遇到 `.`, `..`, ` ` 这三种字符，无操作，continue.
3. 出此之外，一律 push 操作。

注：分割后每一段字符串设为 `tmp`.

```cpp
if (tmp == ".." && !stack.empty()) stack.pop_back();
else if (tmp == "." || tmp == ".." || tmp == "") continue;
else stack.push_back(tmp);
```

然后将栈里面的字符串连接即可：

```cpp
for (auto str : stack) { ret += "/" + str; }
```

这里提示 C++ 中字符串分割的基本技巧：**使用 `istringstream`, 配合 `getline(iss, tmp, '/')`**

不多说，不超过十行。AC

PS:

**使用 `istringstream`, 配合 `getline(iss, tmp, '/')`**

**使用 `istringstream`, 配合 `getline(iss, tmp, '/')`**

**使用 `istringstream`, 配合 `getline(iss, tmp, '/')`**