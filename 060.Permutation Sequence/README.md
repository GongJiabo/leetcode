60. Permutation Sequence

给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。
示例 1:

输入: n = 3, k = 3
输出: "213"
示例 2:

输入: n = 4, k = 9
输出: "2314"

my_own:  
  想过排列组合出所有的可能，保存到容器中，进行sort排序后直接取第几个为结果，但是这样
  时间和空间复杂度太高，对于前面较小的数不太好。  
   与人自己排列一样，从高位开始排列起，从高位到低位，找到所需大小数各个位置上的值。如n位数，那么以1开头的数有(n-1)!个，比较所需k是否小于(n-1)!，若大于，则比较2*(n-1)!，如果小于则，该数以2开头，与此类似，得到各位的值。

solution(from pezy):

首先，这个组合的顺序与 `std::next_permutation` 的顺序一致。可以参考 [排列组合技术](http://segmentfault.com/blog/pezy/1190000002486075)。


但如果这道题，直接使用 `std::next_permutation` 的话，会 TimeOut.

所以应该直接定位到 k 位置的字符串，而不是将所有组合都迭代一遍。

-----

需要两个索引表：

**table**

| n | 组合个数 |
|:-:|:--------:|
| 0 |     1    |
| 1 |    1!    |
| 2 |    2!    |
| 3 |    3!    |
| 4 |    4!    |
| 5 |    5!    |
| 6 |    6!    |
| 7 |    7!    |
| 8 |    8!    |
| 9 |    9!    |

**dictionary**

    1 2 3 4 5 6 7 8 9
    
那么如果有了 k, 对于长度为 n 的字符串来说，首先要定位的是其开头字符。

    int pos = (k-1)/table[n-1];
    ret += dict[pos];

出现过的字符，不应再有机会出现，故删除之。并继续查看后面的字符。同时 k 也要减掉之前计算过的 pos.

    dict.earse(dict.begin() + pos);
    k = k - pos * table[n-1];
